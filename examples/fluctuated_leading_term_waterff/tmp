Traced<ConcreteArray([-0.7778535   0.38892674  0.38892674 -0.7754795   0.38773975  0.38773975], dtype=float32)>with<JVPTrace(level=2/0)> with
  primal = DeviceArray([-0.7778535 ,  0.38892674,  0.38892674, -0.7754795 ,
              0.38773975,  0.38773975], dtype=float32)
  tangent = Traced<ShapedArray(float32[6])>with<JaxprTrace(level=1/0)> with
    pval = (ShapedArray(float32[6]), None)
    recipe = JaxprEqnRecipe(eqn_id=<object object at 0x2b007bfcd710>, in_tracers=(Traced<ConcreteArray([0. 0. 0. 0. 0. 0.], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[0]
 [3]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(-2.0, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.9748537 0.9918169], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.37914667 0.38456684], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([1.0522553 1.0165694], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(0.002287250943481922, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(3.1415927410125732, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(180.0, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([-1.0191996 -1.0199215], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.95385516 0.9579607 ], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([-0.18427183 -0.18841235], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([1.0990947 1.0896941], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[-0.12199974  0.40999988 -0.87999994]
 [ 0.9390001   0.11800004 -0.19300002]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[ 0.5959997  -0.74000007 -0.21799994]
 [ 0.03000069 -0.27999997  0.95099986]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[31.289  0.     0.   ]
 [ 0.    31.289  0.   ]
 [ 0.     0.    31.289]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[0.03196011 0.         0.        ]
 [0.         0.03196011 0.        ]
 [0.         0.         0.03196011]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[1]
 [4]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[0]
 [3]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[31.289  0.     0.   ]
 [ 0.    31.289  0.   ]
 [ 0.     0.    31.289]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[0.03196011 0.         0.        ]
 [0.         0.03196011 0.        ]
 [0.         0.         0.03196011]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[2]
 [5]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.97845984 0.96586454], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.5128975 0.5041253], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[ 0.5959997  -0.74000007 -0.21799994]
 [ 0.03000069 -0.27999997  0.95099986]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.5110072 0.5176709], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[-0.12199974  0.40999988 -0.87999994]
 [ 0.9390001   0.11800004 -0.19300002]], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(0.2396675944328308, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(-0.07048343867063522, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[1]
 [4]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[2]
 [5]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0. 0. 0. 0. 0. 0.], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[0]
 [3]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.01344353 0.01342371], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(2625.5, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(0.02191462367773056, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(0.09324789047241211, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(11.903953552246094, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[1]
 [4]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.0703179  0.07011013], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([2 2], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0. 0.], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([ True  True], dtype=bool):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0. 0.], dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(2625.5, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(0.02191462367773056, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(-0.007049237843602896, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(1.9494296312332153, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray(2.097120761871338, dtype=float32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([[2]
 [5]], dtype=int32):JaxprTrace(level=1/0)>, Traced<ConcreteArray([0.0703179  0.07011013], dtype=float32):JaxprTrace(level=1/0)>, Traced<ShapedArray(float32[6,3]):JaxprTrace(level=1/0)>), out_tracer_refs=[<weakref at 0x2b01b3f6d770; to 'JaxprTracer' at 0x2b01b3f6d4f0>, <weakref at 0x2b01b3f6d450; to 'JaxprTracer' at 0x2b01b3f6d6d0>], out_avals=[ShapedArray(float32[6]), ShapedArray(float32[6])], primitive=xla_call, params={'device': None, 'backend': None, 'name': 'jvp(compute_leading_terms)', 'donated_invars': (False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False), 'inline': False, 'keep_unused': False, 'call_jaxpr': { lambda ; a:f32[6] b:i32[2,1] c:f32[] d:f32[2] e:f32[2] f:f32[2] g:f32[] h:f32[]
    i:f32[] j:f32[2] k:f32[2] l:f32[2] m:f32[2] n:f32[2,3] o:f32[2,3] p:f32[3,3]
    q:f32[3,3] r:i32[2,1] s:i32[2,1] t:f32[3,3] u:f32[3,3] v:i32[2,1] w:f32[2] x:f32[2]
    y:f32[2,3] z:f32[2] ba:f32[2,3] bb:f32[] bc:f32[] bd:i32[2,1] be:i32[2,1] bf:f32[6]
    bg:i32[2,1] bh:f32[2] bi:f32[] bj:f32[] bk:f32[] bl:f32[] bm:i32[2,1] bn:f32[2]
    bo:i32[2] bp:f32[2] bq:bool[2] br:f32[2] bs:f32[] bt:f32[] bu:f32[] bv:f32[]
    bw:f32[] bx:i32[2,1] by:f32[2] bz:f32[6,3]. let
    ca:f32[2,3] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,))
      fill_value=None
      indices_are_sorted=True
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(1, 3)
      unique_indices=True
    ] bz r
    cb:f32[2,3] = broadcast_in_dim[broadcast_dimensions=(0, 1) shape=(2, 3)] ca
    cc:f32[2,3] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,))
      fill_value=None
      indices_are_sorted=True
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(1, 3)
      unique_indices=True
    ] bz s
    cd:f32[2,3] = broadcast_in_dim[broadcast_dimensions=(0, 1) shape=(2, 3)] cc
    ce:f32[2,3] = xla_call[
      call_jaxpr={ lambda ; cf:f32[2,3] cg:f32[2,3]. let
          ch:f32[2,3] = sub cf cg
        in (ch,) }
      name=jvp(<lambda>)
    ] cb cd
    ci:f32[2,3] = xla_call[
      call_jaxpr={ lambda ; cj:f32[3,3] ck:f32[3,3] cl:f32[2,3]. let
          cm:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; cn:f32[3,3] co:f32[2,3]. let
                cp:f32[2,3] = dot_general[
                  dimension_numbers=(((1,), (0,)), ((), ()))
                  precision=None
                  preferred_element_type=None
                ] co cn
              in (cp,) }
            name=jvp(vmap(dot))
          ] ck cl
          cq:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; cr:f32[2,3]. let  in (cr,) }
            name=jvp(vmap(<lambda>))
          ] cm
          cs:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; ct:f32[3,3] cu:f32[2,3]. let
                cv:f32[2,3] = dot_general[
                  dimension_numbers=(((1,), (0,)), ((), ()))
                  precision=None
                  preferred_element_type=None
                ] cu ct
              in (cv,) }
            name=jvp(vmap(dot))
          ] cj cq
        in (cs,) }
      name=jvp(vmap(pbc_shift))
    ] p q ce
    cw:f32[2,3] = gather[
      dimension_numbers=GatherDimensionNumbers(offset_dims=(1,), collapsed_slice_dims=(0,), start_index_map=(0,))
      fill_value=None
      indices_are_sorted=True
      mode=GatherScatterMode.PROMISE_IN_BOUNDS
      slice_sizes=(1, 3)
      unique_indices=True
    ] bz v
    cx:f32[2,3] = broadcast_in_dim[broadcast_dimensions=(0, 1) shape=(2, 3)] cw
    cy:f32[2,3] = xla_call[
      call_jaxpr={ lambda ; cz:f32[2,3] da:f32[2,3]. let
          db:f32[2,3] = sub cz da
        in (db,) }
      name=jvp(<lambda>)
    ] cx cd
    dc:f32[2,3] = xla_call[
      call_jaxpr={ lambda ; dd:f32[3,3] de:f32[3,3] df:f32[2,3]. let
          dg:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; dh:f32[3,3] di:f32[2,3]. let
                dj:f32[2,3] = dot_general[
                  dimension_numbers=(((1,), (0,)), ((), ()))
                  precision=None
                  preferred_element_type=None
                ] di dh
              in (dj,) }
            name=jvp(vmap(dot))
          ] de df
          dk:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; dl:f32[2,3]. let  in (dl,) }
            name=jvp(vmap(<lambda>))
          ] dg
          dm:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; dn:f32[3,3] do:f32[2,3]. let
                dp:f32[2,3] = dot_general[
                  dimension_numbers=(((1,), (0,)), ((), ()))
                  precision=None
                  preferred_element_type=None
                ] do dn
              in (dp,) }
            name=jvp(vmap(dot))
          ] dd dk
        in (dm,) }
      name=jvp(vmap(pbc_shift))
    ] t u cy
    dq:f32[2,3] = xla_call[
      call_jaxpr={ lambda ; dr:f32[2,3] ds:f32[2,3] dt:f32[2,3] du:f32[2,3]. let
          dv:f32[2,3] = mul dt dr
          dw:f32[2,3] = mul ds du
          dx:f32[2,3] = add_any dv dw
        in (dx,) }
      name=jvp(fn)
    ] n o ci dc
    dy:f32[2] = xla_call[
      call_jaxpr={ lambda ; dz:f32[2,3]. let
          ea:f32[2] = reduce_sum[axes=(1,)] dz
        in (ea,) }
      name=jvp(_reduce_sum)
    ] dq
    eb:f32[2] = xla_call[
      call_jaxpr={ lambda ; ec:f32[2] ed:f32[2,3] ee:f32[2,3]. let
          ef:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; eg:f32[2,3]. let  in (eg,) }
            name=jvp(conjugate)
          ] ee
          eh:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; ei:f32[2,3] ej:f32[2,3] ek:f32[2,3] el:f32[2,3]. let
                em:f32[2,3] = mul ek ei
                en:f32[2,3] = mul ej el
                eo:f32[2,3] = add_any em en
              in (eo,) }
            name=jvp(fn)
          ] ed ed ee ef
          ep:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; eq:f32[2,3]. let  in (eq,) }
            name=jvp(real)
          ] eh
          er:f32[2] = xla_call[
            call_jaxpr={ lambda ; es:f32[2,3]. let
                et:f32[2] = reduce_sum[axes=(1,)] es
              in (et,) }
            name=jvp(_reduce_sum)
          ] ep
          eu:f32[2] = xla_call[
            call_jaxpr={ lambda ; ev:f32[2] ew:f32[2]. let
                ex:f32[2] = mul ew ev
              in (ex,) }
            name=jvp(<lambda>)
          ] ec er
        in (eu,) }
      name=jvp(norm)
    ] x y ci
    ey:f32[2] = xla_call[
      call_jaxpr={ lambda ; ez:f32[2] fa:f32[2,3] fb:f32[2,3]. let
          fc:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; fd:f32[2,3]. let  in (fd,) }
            name=jvp(conjugate)
          ] fb
          fe:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; ff:f32[2,3] fg:f32[2,3] fh:f32[2,3] fi:f32[2,3]. let
                fj:f32[2,3] = mul fh ff
                fk:f32[2,3] = mul fg fi
                fl:f32[2,3] = add_any fj fk
              in (fl,) }
            name=jvp(fn)
          ] fa fa fb fc
          fm:f32[2,3] = xla_call[
            call_jaxpr={ lambda ; fn:f32[2,3]. let  in (fn,) }
            name=jvp(real)
          ] fe
          fo:f32[2] = xla_call[
            call_jaxpr={ lambda ; fp:f32[2,3]. let
                fq:f32[2] = reduce_sum[axes=(1,)] fp
              in (fq,) }
            name=jvp(_reduce_sum)
          ] fm
          fr:f32[2] = xla_call[
            call_jaxpr={ lambda ; fs:f32[2] ft:f32[2]. let
                fu:f32[2] = mul ft fs
              in (fu,) }
            name=jvp(<lambda>)
          ] ez fo
        in (fr,) }
      name=jvp(norm)
    ] z ba dc
    fv:f32[2] = xla_call[
      call_jaxpr={ lambda ; fw:f32[2] fx:f32[2] fy:f32[2] fz:f32[2]. let
          ga:f32[2] = mul fy fw
          gb:f32[2] = mul fx fz
          gc:f32[2] = add_any ga gb
        in (gc,) }
      name=jvp(fn)
    ] w d eb ey
    gd:f32[2] = xla_call[
      call_jaxpr={ lambda ; ge:f32[2] gf:f32[2] gg:f32[2] gh:f32[2] gi:f32[2]. let
          gj:f32[2] = div gh ge
          gk:f32[2] = neg gi
          gl:f32[2] = mul gk gf
          gm:f32[2] = mul gl gg
          gn:f32[2] = add_any gj gm
        in (gn,) }
      name=jvp(true_divide)
    ] k l m dy fv
    go:f32[2] = xla_call[
      call_jaxpr={ lambda ; gp:f32[2] gq:f32[2]. let
          gr:f32[2] = mul gq gp
        in (gr,) }
      name=jvp(<lambda>)
    ] j gd
    gs:f32[2] = xla_call[
      call_jaxpr={ lambda ; gt:f32[] gu:f32[2]. let
          gv:f32[2] = mul gu gt
        in (gv,) }
      name=jvp(fn)
    ] i go
    gw:f32[2] = xla_call[
      call_jaxpr={ lambda ; gx:f32[] gy:f32[2]. let
          gz:f32[2] = div gy gx
        in (gz,) }
      name=jvp(true_divide)
    ] h gs
    ha:f32[2] = xla_call[
      call_jaxpr={ lambda ; hb:f32[] hc:f32[2]. let
          hd:f32[2] = mul hc hb
        in (hd,) }
      name=jvp(fn)
    ] g gw
    he:f32[2] = xla_call[
      call_jaxpr={ lambda ; hf:f32[2]. let  in (hf,) }
      name=jvp(fn)
    ] ha
    hg:f32[2] = xla_call[
      call_jaxpr={ lambda ; hh:f32[] hi:f32[2]. let
          hj:f32[2] = mul hi hh
        in (hj,) }
      name=jvp(fn)
    ] bb eb
    hk:f32[2] = xla_call[
      call_jaxpr={ lambda ; hl:f32[2] hm:f32[2]. let
          hn:f32[2] = add hl hm
        in (hn,) }
      name=jvp(fn)
    ] he hg
    ho:f32[2] = xla_call[
      call_jaxpr={ lambda ; hp:f32[] hq:f32[2]. let
          hr:f32[2] = mul hq hp
        in (hr,) }
      name=jvp(fn)
    ] bc ey
    hs:f32[2] = xla_call[
      call_jaxpr={ lambda ; ht:f32[2] hu:f32[2]. let
          hv:f32[2] = add ht hu
        in (hv,) }
      name=jvp(fn)
    ] hk ho
    hw:f32[2] = xla_call[
      call_jaxpr={ lambda ; hx:f32[2] hy:f32[2] hz:f32[2] ia:f32[2] ib:f32[2]. let
          ic:f32[2] = div ia hx
          id:f32[2] = neg ib
          ie:f32[2] = mul id hy
          if:f32[2] = mul ie hz
          ig:f32[2] = add_any ic if
        in (ig,) }
      name=jvp(true_divide)
    ] d e f hs eb
    ih:f32[2] = xla_call[
      call_jaxpr={ lambda ; ii:f32[] ij:f32[2]. let
          ik:f32[2] = mul ij ii
        in (ik,) }
      name=jvp(fn)
    ] c hw
    il:f32[2] = xla_call[
      call_jaxpr={ lambda ; im:f32[2]. let  in (im,) }
      name=jvp(_squeeze)
    ] ih
    in:f32[6] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr={ lambda ; io:f32[] ip:f32[]. let  in (ip,) }
    ] a b il
    iq:f32[2] = xla_call[
      call_jaxpr={ lambda ; ir:f32[2]. let  in (ir,) }
      name=jvp(_squeeze)
    ] hw
    is:f32[6] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr={ lambda ; io:f32[] ip:f32[]. let  in (ip,) }
    ] in bd iq
    it:f32[2] = xla_call[
      call_jaxpr={ lambda ; iu:f32[2]. let  in (iu,) }
      name=jvp(_squeeze)
    ] hw
    iv:f32[6] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr={ lambda ; io:f32[] ip:f32[]. let  in (ip,) }
    ] is be it
    iw:f32[2] = xla_call[
      call_jaxpr={ lambda ; ix:f32[] iy:f32[2]. let
          iz:f32[2] = mul iy ix
        in (iz,) }
      name=jvp(fn)
    ] bk gw
    ja:f32[2] = xla_call[
      call_jaxpr={ lambda ; jb:f32[2]. let  in (jb,) }
      name=jvp(fn)
    ] iw
    jc:f32[2] = xla_call[
      call_jaxpr={ lambda ; jd:f32[2] je:f32[2]. let
          jf:f32[2] = add jd je
        in (jf,) }
      name=jvp(fn)
    ] eb ey
    jg:f32[2] = xla_call[
      call_jaxpr={ lambda ; jh:f32[] ji:f32[2]. let
          jj:f32[2] = mul ji jh
        in (jj,) }
      name=jvp(fn)
    ] bl jc
    jk:f32[2] = xla_call[
      call_jaxpr={ lambda ; jl:f32[2] jm:f32[2]. let
          jn:f32[2] = add jl jm
        in (jn,) }
      name=jvp(fn)
    ] ja jg
    jo:f32[2] = xla_call[
      call_jaxpr={ lambda ; jp:f32[] jq:f32[2]. let
          jr:f32[2] = mul jq jp
        in (jr,) }
      name=jvp(fn)
    ] bj jk
    js:f32[2] = xla_call[
      call_jaxpr={ lambda ; jt:f32[] ju:f32[2]. let
          jv:f32[2] = mul ju jt
        in (jv,) }
      name=jvp(fn)
    ] bi jo
    jw:f32[2] = xla_call[
      call_jaxpr={ lambda ; jx:f32[2] jy:f32[2]. let
          jz:f32[2] = mul jy jx
        in (jz,) }
      name=jvp(<lambda>)
    ] bh js
    ka:f32[2] = xla_call[
      call_jaxpr={ lambda ; kb:f32[2]. let  in (kb,) }
      name=jvp(_squeeze)
    ] jw
    kc:f32[6] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr={ lambda ; io:f32[] ip:f32[]. let  in (ip,) }
    ] bf bg ka
    kd:f32[2] = xla_call[
      call_jaxpr={ lambda ; ke:f32[] kf:f32[2]. let
          kg:f32[2] = mul kf ke
        in (kg,) }
      name=jvp(fn)
    ] bu gw
    kh:f32[2] = xla_call[
      call_jaxpr={ lambda ; ki:f32[2]. let  in (ki,) }
      name=jvp(fn)
    ] kd
    kj:f32[2] = xla_call[
      call_jaxpr={ lambda ; kk:f32[] kl:f32[2]. let
          km:f32[2] = mul kl kk
        in (km,) }
      name=jvp(fn)
    ] bv eb
    kn:f32[2] = xla_call[
      call_jaxpr={ lambda ; ko:f32[2] kp:f32[2]. let
          kq:f32[2] = add ko kp
        in (kq,) }
      name=jvp(fn)
    ] kh kj
    kr:f32[2] = xla_call[
      call_jaxpr={ lambda ; ks:f32[] kt:f32[2]. let
          ku:f32[2] = mul kt ks
        in (ku,) }
      name=jvp(fn)
    ] bw ey
    kv:f32[2] = xla_call[
      call_jaxpr={ lambda ; kw:f32[2] kx:f32[2]. let
          ky:f32[2] = add kw kx
        in (ky,) }
      name=jvp(fn)
    ] kn kr
    kz:f32[2] = xla_call[
      call_jaxpr={ lambda ; la:f32[] lb:f32[2]. let
          lc:f32[2] = mul lb la
        in (lc,) }
      name=jvp(fn)
    ] bt kv
    ld:f32[2] = xla_call[
      call_jaxpr={ lambda ; le:f32[] lf:f32[2]. let
          lg:f32[2] = mul lf le
        in (lg,) }
      name=jvp(fn)
    ] bs kz
    lh:f32[2] = xla_call[
      call_jaxpr={ lambda ; li:i32[2] lj:f32[2] lk:bool[2] ll:f32[2] lm:f32[2]. let
          ln:f32[2] = xla_call[
            call_jaxpr={ lambda ; lo:i32[2] lp:f32[2] lq:bool[2] lr:f32[2] ls:f32[2]. let
                lt:f32[2] = select_n lq lr ls
                lu:f32[2] = select_n lo lp lp lt
              in (lu,) }
            name=jvp(_piecewise)
          ] li lj lk ll lm
        in (ln,) }
      name=jvp(trim_val_0)
    ] bo bp bq br ld
    lv:f32[2] = xla_call[
      call_jaxpr={ lambda ; lw:f32[2] lx:f32[2]. let
          ly:f32[2] = mul lx lw
        in (ly,) }
      name=jvp(<lambda>)
    ] bn lh
    lz:f32[2] = xla_call[
      call_jaxpr={ lambda ; ma:f32[2]. let  in (ma,) }
      name=jvp(_squeeze)
    ] lv
    mb:f32[6] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr={ lambda ; io:f32[] ip:f32[]. let  in (ip,) }
    ] kc bm lz
    mc:f32[2] = xla_call[
      call_jaxpr={ lambda ; md:f32[2] me:f32[2]. let
          mf:f32[2] = mul me md
        in (mf,) }
      name=jvp(<lambda>)
    ] by lh
    mg:f32[2] = xla_call[
      call_jaxpr={ lambda ; mh:f32[2]. let  in (mh,) }
      name=jvp(_squeeze)
    ] mc
    mi:f32[6] = scatter[
      dimension_numbers=ScatterDimensionNumbers(update_window_dims=(), inserted_window_dims=(0,), scatter_dims_to_operand_dims=(0,))
      indices_are_sorted=True
      mode=GatherScatterMode.FILL_OR_DROP
      unique_indices=True
      update_consts=()
      update_jaxpr={ lambda ; io:f32[] ip:f32[]. let  in (ip,) }
    ] mb bx mg
  in (iv, mi) }}, effects=set(), source_info=SourceInfo(traceback=<jaxlib.xla_extension.Traceback object at 0x2b01b3fa64b0>, name_stack=NameStack(stack=(Transform(name='jvp'),))))
